----readMe.txt
/*
*********************************************************************************************************
* 设 计 者：王远，常州赛乐医疗技术有限公司
* 邮    箱：wy18676382209@163.com
* 更新日期：2021-06-11
* 硬 	件：TMY_V0.2_20200524（Design by 王远, Layout by 王昌盛）
*********************************************************************************************************
*/
-----------------------------------------------------------------------------------------------------------------
stm32F401CEUx:
		512kB Flash, 96kB RAM
主存储区(代码区)：
		扇区		地址						大小
		扇区 0		0x0800 0000 - 0x0800 3FFF 	16 KB		--	Bootloader
		扇区 1		0x0800 4000 - 0x0800 7FFF 	16 KB
		
		
		扇区 2		0x0800 8000 - 0x0800 BFFF 	16 KB		--	Code
		扇区 3		0x0800 C000 - 0x0800 FFFF 	16 KB
		扇区 4		0x0801 0000 - 0x0801 FFFF 	64 KB
		扇区 5		0x0802 0000 - 0x0803 FFFF 	128 KB
		
		
		扇区 6		0x0804 0000 - 0x0805 FFFF 	128 KB		--	Flash_DB(保留，现在采用EEPROM)
		扇区 7		0x0806 0000 - 0x0807 FFFF 	128 KB		
										合计：	512	KB
-----------------------------------------------------------------------------------------------------------------									
编译后的程序空间分配：
存储Size:
		RO size: Code + RO_data，	表示程序占用Flash空间的大小。
		RW size: RW_data + ZI_data，表示运行时占用RAM的大小。
		ROM （minimum）size = Code + RO_data + RW_data （即烧/下载程序到FLASH/ROM时，所占用的最小空间）
		Total ROM Size (Code + RO Data + RW Data)这样所写的程序占用的ROM的字节总数，也就是说程序所下载到ROM flash 中的大小。
		为什么Rom中还要存RW，因为掉电后RAM中所有数据都丢失了，每次上电RAM中的数据是被重新赋值的，
		每次这些固定的值就是存储在Rom中的，为什么不包含ZI段呢，是因为ZI数据都是0，没必要包含，
		只要程序运行之前将ZI数据所在的区域一律清零即可。包含进去反而浪费存储空间。
		RAM相当于内存，Flash相当于硬盘。
-----------------------------------------------------------------------------------------------------------------		
2021-06-03： 开始制作bootloader,参考学长分享的开源bootloader,见	TMY_Bootloaderxxx
		用户区间：	Flash起始地址：0x8008000		大小：0x78000,
								   注意：一定要在system_stm32f4xx.c文件中修改中断向量“偏移地址”VECT_TAB_OFFSET，其值与
								   Flash起始地址一致且必须位0x200的整数倍，如我这里修改VECT_TAB_OFFSET = 0x8000
		
		Boot区间：	Flash起始地址：0x8000000		大小：0x08000
-----------------------------------------------------------------------------------------------------------------		
2021-06-10:		外设分配
		1. 更换芯片，由stm32f401RET6更改为stm32f401CEUx，硬件电路对应TMY_V0.2_20200524版本；
		2. 更改后的主要外设说明：
			USART1(中断)&TIM9(中断，超时监测)		---{>}	WIFI
			USART2(中断) 			 				---{>}	debugUART &	serialLCD
			TIM3(中断)								---{>}	keyScan,秒标志器
			TIM4_PWM_CH2							---{>}	蜂鸣器
			SPI1									---{>}	外部Flash(W25Q32)
			SPI3									---{>}	电机模块MP6570
-----------------------------------------------------------------------------------------------------------------		
2021-06-11:		移植
		1. WIFI移植&整合成功；
		2. debugUART移植&整合成功；
		3. keyScan&秒标志位移植&整合成功；
		4. 蜂鸣器移植&整合成功；
		5. 外部Flash移植&整合成功
		6. AD_DMA模块，移植成功；增加一个通道AD用于监测脚踏：
			脚踏电压范围：1.70V -- 1.85V,动态范围150mV，太窄；

2021-06-11:		USB MSC_CDC系统
-----------------------------------------------------------------------------------------------------------------
		注意，由于已经对CUBE MX生成的USB MSC_CDC进行了分离，所以在使用过程中，如果存在“再次使用CUBE MX生成代码”,
		请修改和移除以下文件：
		0. CUBE MX  使能  USB On The Go global interrupt
		1. main.c:	删除或屏蔽
					“#include "usb_otg.h"”
					“MX_USB_OTG_FS_PCD_Init();”
		2. usb_otg.c: 在工程中 移除
		3. 添加“USB_Interface_Setting”文件夹内.c和.h文件至工程中，配置相关路径。
		
		说明：
		1. 由于需要用到USB CDC 和 MSC两种功能，需要将系统堆、栈设置大一些，调试时建议先将堆、栈设置足够大，
		再采用二分法“试减”堆栈大小，确保功能VS速度满足项目需求；
		2. 在 CDC_DATA_FS_MAX_PACKET_SIZE	宏定义中规定了USB CDC每一帧最大的数据量，可随项目需求自己更改；
		
2021-06-15：
		1. USB MSC_CDC系统 移植&整合成功；
		2. SPI Flash --{>} Fats文件系统，移植&整合成功；
		3. 增加HX711/HX712驱动文件：使用之前需校准，对 AD vs 力 进行拟合
		
2021-06-16:
		1. 修改了"usbd_cdc_if.h"和"usbd_cdc_if.c"文件，增加了usb_printf函数；
		2. 使用usb_printf替换了所有printf函数;
		3. 调整了外设初始化顺序,保证当前外设不再依赖于printf输出调试信息，而是使用usb_printf

-------------------------------------------------------------------------------------------------------
									开始移植FreeRTOS
		2021-06-17:
		1. 熟悉FreeRTOS
		
		2021-06-18:
		1. 尝试从源码移植FreeRTOS

		2021-06-21:
		1. 采用CubeMx生成FreeRTOS；
		2. 移植串口2		成功；
		3. 移植蜂鸣器		成功；
		4. 移植SPI Flash	成功；
		
		2021-06-22：
		1. 移植WIFI			成功；
		2. 移植Fats文件系统	成功；
		3. 移植USB_CDC_MSC	成功；

		2021-06-23:
		1. 移植ADC			成功；
		2. 移植HX711		成功；

		2021-06-24：
		1. 编写串口屏驱动（品牌：广州大彩，型号：DC48854M050）
		
		2021-06-25:
		请假
		
		2021-06-28：
		1. 编写SerialLCD.c， SerialLCD.h文件

		2021-06-29：
		1. 调整串口屏数据接收处理机制：建立2级缓存，
				第1级缓存用于用于记录每帧数据的帧头和帧尾所在位置，并对数据进行分帧，待分帧完成将数据存储于第2级缓存；
				第2级缓存开始对数据进行解析，实现人机交互；
		2021-06-30：
		1. 串口屏通信进程经常死机：
				寻找程序Bug，发现不是系统调度问题，而是第一级中索引溢出
				修复Bug，测试结果：连续200次人机交互没有问题
		2021-07-01：
		1. 移植大彩串口屏hmi_driver.c hmi_driver.h文件
		2. 串口屏压力传感器动态波形展示
		3. 串口屏脚踏踩踏动态压力展示
		
		2021-07-02:
		1. 开始编写UI应用层逻辑：
			1）、控件单元
			2）、界面结构
			3）、属性
			
		2021-07-05：
		1. UI分层：底层{<}-{>}中间层{<}-{>}应用层
		2. 代码搬移，把SerialLCD.c中一些属于中间层的函数模块迁移至Display.c中
		
		2021-07-06:
		1. 界面7:	Anesthesia,配置完成
		2. 界面3：	Setting,配置完成
		
		2021-07-07：
		1. 界面2：
			1）、AT框架移植：昨晚刚好看到一个比较号的AT指令处理框架，决定移植到本系统中

		2021-07-08:
		1. 移植AT框架成功，但是测试时发现长响应参数无法接收完全
		
		2021-07-09---2021-07-17：
		1. 见工作日志，该段时间主要负责编写CE注册软件资料；
		
		2021-07-19:
		1. AT处理框架确定存在问题，开始参照该框架编写适合本项目的AT处理框架

		2021-07-20---2021-07-23:
		1. AT处理框架编写完成并测试通过
	
		2021-07-28---2021-08-05:
		1. WIFI连接成功；

		2021-08-05---2021-08-16：
		1. 测试液压传感器MPM288和电机推力
		2. 液压传感器无法正常读数
		3. 电机推力不足
		
		2021-08-17---2021-08-27:
		1. 阅读MP6570和MP654x数据手册，
		2. 修改底层电机驱动库，移除电机.Lib文件
		3. 编写电机控制接口
		4. 修改电机100us中断执行函数，时间由70us缩短至50us
		
		2021-08-30：
		1. 新增CS1231.c 和CS1231.h文件，用于对液压传感器进行采样，HX711/712 60us即进入睡眠，而中断每次执行50us+,导致数据无法正确读出
		2. 发现CS1231有负压出现
		

		2021-10-19~2021-10-21：
		1. 串口屏驱动更换
		2. 移除WIFI模块

		2021-10-22:
		1. 修改任务（Task）执行时间，使电机运转过程中可无需关闭其他进程

		2021-12-17：
		1. 液压传感器线序：
			蓝色：输出负（-OUT）  --{>}    
			黄色：输入负（-IN）   --{>}  
			黑色：输入正（+IN）   --{>}  
			红色：输出正（+OUT）  --{>}  
			
		2021-12-25:
		1. 移植FAL: Flash Abstract Layer, 详细参见：http://packages.rt-thread.org/detail.html package=fal
		2. 移植FlashDB：Flash Database,   详情参见：https://gitee.com/Armink/FlashDB
		
		2022-01-05：
		1. 升级电路板：TMY_V0.3(晶振8MHz)  --{>}  TMY_V0.5(12MHz)
		2. 更改时钟：
			1. main.c文件中，146行“RCC_OscInitStruct.PLL.PLLM = 4”改为“RCC_OscInitStruct.PLL.PLLM = 6”
			2. stm32f4xx_hal_conf.h为文件中， 95行“#define HSE_VALUE    ((uint32_t)8000000U)”改为“#define HSE_VALUE    ((uint32_t)12000000U)”；
		3. 更改串口（USART2）屏通信波特率：115200 --{>} 9600
		4. 减速比：“64*2 = 128”改为“64*1.6 = 102”，在macro.h文件中更改
		
2022-03-04：  TMY_WithRTOS_V0.4_C03
		1. 更改串口屏切换画面机制，所有切换画面操作均有单片机发送指令完成。
		
2022-03-31：  TMY_WithRTOS_V0.4_C04
		1. 删除不用的模块：C322 WIFI模块，定时器模块， LED指示灯，实体按键；
		2. 设置BEEP引脚为推挽输出，用于配置模拟开关；
		3. 设置HX711_DOUT引脚为开漏输出，发现无法读取液压（原先配置为输入：GPIO_NOPULL，液压获取正常）；
		4. 用cubeMx生成代码后，注意将运行电机的定时器中断级别设置为最高。
		
2022-03-31：  TMY_WithRTOS_V0.4_C05
		1. cubeMx配置HX711_DOUT引脚为输入GPIO_NOPULL，以优先保证可以采集液压
		
		2022-04-06：  
		1. 上电读取EEPROM,获取液压校正系数；然后切换HX711_DOUT引脚为输入GPIO_NOPULL，采集液压
		
2022-04-11：  TMY_WithRTOS_V0.4_C06
		1. 梳理软件架构，升级UI界面
		
2022-04-19：  TMY_WithRTOS_V0.4_C07
		1. 更改底层串口库为hal库；
		2. 重新梳理freeRTOS.c文件，仅保留任务，外设初始化置于app_main.c文件中；

		2022-04-20:
		1. 串口接收回调函数重写，并将
		2. 改写串口屏指令发送框架，采用"多进一出"原理，将待发送指令装入发送缓冲区队列，由同一进程进行指令发送（避免多任务指令发送冲突）。
		
		2022-04-21:		
		1. 优化了切屏卡顿问题；
		2. 优化了充电检测滞后问题；
		
2022-04-25:	  TMY_WithRTOS_V0.4_C08
		1. 增加界面CheckHandle和CheckORing，用于开机检测O型圈性能
		2. 增加关机丝杆回退底部功能
		
		2022-04-26:
		1. 增加N_TIME_CHECK_ORING，运行N次后才会在开机状态下检测O型圈状态;
		2. 优化电池跳动问题

2022-04-27：  TMY_WithRTOS_V0.4_C08
		1. 发现Mode任务运行一段时间后无法正常运行，启动调试，观察现象。
		2. 准备更改电机驱动由位置模式转为速度模式
		
2022-04-27:  TMY_WithRTOS_V0.4_C09
		1. 切换电机驱动为速度模式
		
2022-05-05:  TMY_WithRTOS_V0.4_C10
		1. 切换屏幕未"中显"的串口屏
		
		2022-05-06   2022-05-23:
		1. 改写屏幕通信协议，重新设计UI
		
2022-05-23:	 TMY_WithRTOS_V0.4_C11
		1. 更改Anesthesia界面下“Normal”“Fast” “PDL” “Setting”按钮为‘位图标按钮’模式，产生互斥效果
		2. 发现串口屏通信丢失原因，通信速率过高，后发现是串口中断处理慢造成，将波特率由115200-{>}38400
		
		2022-05-24:
		1. 更改串口数据第二缓存处理流程，提高屏幕交互效率；
		2. 修复老化时，CS1231死机bug；
		
		2022-05-25
		1. 修复脚踏检测bug;
		2. 修复速度显示bug;
		
2022-07-12：TMY_WithRTOS_V0.4_C12 ：电机校正采用底部矫正，固定行程为1080cycles,即电机从“最底部”到达“最顶部”所转圈数固定为“1080圈”； 
		1. 电机停止应在中断里执行，保证可及时响应。
		
		2022-07-13:
		1. 完成校正、老化、Mode应用下，所有电机的停止在中断中执行，提升系统对电机控制的时效性；
		2. 测试系统在电机最快速中（设计规格里）的制动性能；
		
		2022-07-14， 2022-07-18：
		1. 采集数据，对液压原点数据识别算法进行验证；
		
		2022-07-19:
		1. 修复电机运转过程中，行程计算跳变问题：在边界处计算会产生阶跃现象，采用偏置补偿方法：
				1）、保证get_current_handle_run_distance()函数始终运行于线性区；
				2）、限定handle_injector_t.BOTTOM_LOC和handle_injector_t.TOP_LOC处于线性递增区域；
		2. 采集数据，验证液压原点数据识别算法；
		
		2022-07-20：
		1. 移植液压原点寻找算法，并验证成功；
		
		2022-07-21：
		1. 问题：液压采集过程中，会偶发性出现跳跃现象（异常点）：
			1）、采集数据在Matlab中查看，并寻找可靠的滤波算法，最后发现Hampel滤波算法对去异常点有很好的滤波性能，
			2）、多个样本集的验证下，Hampel滤波均稳定去除异常点；
			
		2022-07-22至2022-07-25：
		1. 在vscode中开发C语言版本Hampel滤波算法；
		2. 在vscode中验证Hampel滤波算法对液压数据样本集的滤波性能；
		
		2022-07-26：
		1. 移植Hampel滤波算法至工程中，修复Hampel滤波算法的bug；
		2. 老化观察，采集的液压数据经过Hanpel滤波后的表现： 和仿真一致。
		
		2022-07-28--2022-07-29：
		1. 修复程序中的小bug;
		2. 制定语音需求。
		
		2022-08-01--2022-08-03：
		1. 调试语音播放、智能提醒和训练模式；
		2. 脚踏功能优化：
		
		2022-08-04：
		1. 修复电池bug，所有显示电池图标均采用相同地址;
		2. 增加电池低电量提醒；
		3. 新增定量注射界面（未完成）
		
2022-08-05：TMY_WithRTOS_V0.4_C13：
		1. 取消液压原点寻找算法，使电机每次回退至最底部再前进固定距离作为液压原点。
		2. 移植最新UI
		
		2022-08-06：
		1. 移植最新的UI；
		2. 修复推麻仪老化偏移bug；
		
		2022-08-08：
		1. 根据最新的UI调整控制，增加定量注射程序
		2. vgus新增82H多地址（2地址，3地址）指令更新程序
		

		2022-08-08--2022-08-09:	

		1. 优化界面控件地址；
		2. 程序优化控制，解决定量注射bug
		
		2022-08-10:	
		1. 居家验证stm32f4串口DMA发送与接收（非定长），接收的数据通过USB_CDC打印出来；
		2. DSP:  core_cm4.h	76行添加#define __FPU_PRESENT  1U /*!{<} FPU present	*/

2022-08-11：TMY_WithRTOS_V0.4_C14：
		1. 全新程序架构调整，USB CDC采用cubemx自动生成的库；
		2. 优化主控与串口屏之间的通信，采用串口+DMA，实现不定长发送与接收，提高HMI交互速度
		
		2022-08-12：
		1. 开机自动寻找液压原点；
		2. 修复回退bug;
		
		2022-08-13:
		1. 修复模式切换时asp异常开启Bug;
		2. 修复已知Bug;
		3. 安排周洵进行“用户测试”，寻找程序bug.
		
2022-08-10：
	1. DSP:  core_cm4.h	76行添加#define __FPU_PRESENT  1U /*!{<} FPU present	*/
	2022-08-10：
	1. 这是一个串口DMA中断收发的例子；
	2. 接收的数据通过USB_CDC打印出来；
	
	2022-08-14:
	1. 修改中断向量表偏移地址：在system_stm32f4xx.c中的
			第95行增加：	#define USER_VECT_TAB_ADDRESS
			第108行修改为：	#define VECT_TAB_OFFSET         0x00008000U

2022-08-10：
	1. DSP:  core_cm4.h	76行添加#define __FPU_PRESENT  1U /*!{<} FPU present	*/
	2022-08-10：
	1. 这是一个串口DMA中断收发的例子；
	2. 接收的数据通过USB_CDC打印出来；
	
	2022-08-14:
	1. 修改中断向量表偏移地址：在system_stm32f4xx.c中的
			第95行增加：		#define USER_VECT_TAB_ADDRESS
			第108行修改为：	#define VECT_TAB_OFFSET         0x00008000U
	2. E_Flow F411CEU6  SPI1&MP6750 : SPI_BAUDRATEPRESCALER_8	{<}={>}	12 MBit/s
	
-------------------------------------------------------------------------------------------------------------------------------------
文件：				|					调试程序：							|						发布程序
system_stm32f4xx.c	|	#define VECT_TAB_OFFSET         0x00000000U			|	#define VECT_TAB_OFFSET         0x00008000U
app_main.c			|	#define VECT_TAB_OFFSET         0x00000000U			|	#define VECT_TAB_OFFSET         0x00008000U
IROM1				|	0x8000000						0x38000				|	0x8008000						0x38000

E_Flow_F411_V01:
	2022-08-14: 
	1. 迁移F401至F411;
	2. 软件命名更改为：E_Flow_F411_V01
	3. 开始制作bootloader程序
	
	2022-08-15：
	1. 制作F401bootloader成功；
	2022-08-16:
	1. 制作F411bootloader成功；
	2. 发现F411对程序适配性不佳（关机一场死机）：原因，关机前Flash保存用户数据异常

E_Flow_F411_V02:
	2022-08-16：
	1. 转移用户数据至EEPROM, 不再利用单片机最后两个扇区（256Kb）作为数据库。
*************************************************************************************************************************************
EEPROM空间划分：
	1. 地址0：		保留；
	2. 地址1-4：		Oil_K液压校准系数K
	3. 地址5-8：		Oil_b液压校准系数b
	
	//	系统参数，起始地址0x20
	4. 地址0：		ASPIRATE   0/1
	5. 地址1：		SMART_REMINDER	0/1
	6. 地址2：		TRAIN_MODE	0/1
	7. 地址3：		VOLUME		[0, MAX_VOLUME_INDEX]
	8. 地址4：		LIGHT		[0, MAX_LIGHT_INDEX]
	9. 地址5-8： 	AGING_CYCLE，uint32_t 类型
	10.地址9-12：	USE_TIMES，uint32_t 类型
	11.地址13：		AUTO_BACK，uint8_t: 0x10表示关闭开机自动回退；其他值表示开启自动回退，默认开启
	12.地址14：		USE_In_CHARGING，uint8_t:0x10表示充电时设备可以使用;其它值表示充电时不可使用。
	13.地址15：		UPDATE_FLAG	0/1:	0: 系统不用更新程序， 1： 系统需要更新程序
	
	//	脚踏参数，起始地址0x40
	11.地址0-3：	MIN，脚踏电压最小值，uint32_t 类型
	12.地址4-7：	MAX，脚踏电压最大值，uint32_t 类型
	13.地址8-11：	QUARTER_DELTA，脚踏电压变化量的1/4，uint32_t 类型
	
	//	手柄注射器的参数，起始地址0x60
	14.地址0-3：	BOTTOM_LOC，手柄底部位置，uint32_t 类型
	15.地址4-7：	TOP_LOC，手柄顶部位置，uint32_t 类型
	16.地址8-11：	DISTANCE，手柄-注射器 总行程：仅校正后更新，uint32_t 类型
	17.地址12-15：	LAST_LOC， 上次电机停转时所在位置：关机时更新，uint32_t 类型
	18.地址16-19：	BOTTM2ORIGIN， 底部到原点的距离：关机时更新，uint32_t 类型
	
*************************************************************************************************************************************
	2022-08-17--2022-08-19：
	1. 删除非必须依赖；
	2. 增加开机不回退机制，但是出厂默认关闭，仅在用户使用过程中，使用密码开启；
	
	2022-08-22--2022-08-24：
	1. 测试E_Flow使用过程中遇到的问题并解决；
	2. 优化电机控制，增加异常监测；
	
	2022-08-25:
	出差上海;
	
	2022-08-26：
	修复E_Flow老化时异常卡死bug;
	
	2022-08-29：
	1. 电机在原点（Origin Point）处的液压值显示为100kPa,低于100kPa时均显示100kPa;

/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V03: 必须使用注满油的手柄
	2022-08-29：
	1. 固定注射行程，这样每次电机从 Bottom -{>} Origin 这段行程Dis = Top - Fix_Dis;
	2. 计划记录Origin处的液压，[Origin, Top-20]这段行程中的液压kPa = Real_kPa - Origin_kPa,即实时显示相对液压;
	
	2022-08-30:
	1. 修改校正时顶端和底端确认机制：如果连续 OVER_IQ_TIME_CALIB 次电流超过预设值，认为到达顶端或底端；
	2. 修改自动回吸机制：先使电机回退至底端在前进至原点；
	
	2022-08-31：
	1. 修复注射完未启动自动回退时，连续发送失能触摸导致自动回退完成时屏幕依然保持触摸失能的bug;

/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V04: 
	2022-08-31：
	1. 增加看门狗复位机制：当电机运转异常时，启动复位：停止电机；
	
	2022-09-01:
	1. Mode模式：丝杆回退过程中增加液压判断，防止回退过程中误判丝杆到达底端；
	
	2022-09-02:
	1. customer_control.c文件：
		1）、增加 OVER_IQ_TIME 常量（用于AGing和Mode）；
		2）、增加 OVER_IQ_TIME_CALIB 常量（用于Calib）；
	2. 准备PackPro.Fill.NanoPix1/2摸底机器；
	
	2022-09-05：
	1. 准备PackPro.Fill.NanoPix1/2摸底机器；
	2. 准备最新Fast-Fill机器，也去摸底；
	2022-09-06--2022-09-07：
	1. 国内PackPro.Fill.NanoPix1/2摸底；
	2022-09-08：
	1. 车子被追尾；
	2022-09-09：
	1. 请假；
	
	2022-09-13：
	1. Calib模式：校正过程中，丝杆由顶端向底端运行过程中，增加液压判断，防止回退误判，造成校正失败；
	
	2022-09-14：
	1. 试产E-Flow有三台异常，其中两台电机问题；一台液压异常，正在分析过程中；
	2022-09-15：
	1. 试产两台电机问题的E-Flow进行更换；
	2. 初步分析液压异常的机器故障为： 液压传感器校正参数异常；
	2022-09-16：EB 1.1.1.03
	1. 增加E-Flow软件版本显示，EB 1.x.x.xx；
	2. 串口屏软件版本由串口屏上位机控制，直接作为屏幕固件固化在屏幕程序中， EBS 1.x.x.xx；
	3. 更改充电状态，电池动态变化；
	
	2022-09-19:	EB 1.1.1.04
	1. Fast Mode缩减一个低速模式,仅保留中速和高速；
	2. PDL模式：提示音后自动注射，再踩下脚踏会自动停止（回吸）注射;
	3. 修复checkOring由版本升级带来的新bug;
	
	2022-09-24: EB 1.1.1.05
	1. 增加低电量保护机制：当电池电量过低时，停止老化，停止注射麻药。
	
/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V05:
	2022-11-01:
	1. 删除SPI2(本用于W25系列Flash，先不用，取消引脚)；
	2. 更改SPI1为DMA发送接收，失败：开启DMA必须中断，而电机控制的定时器中断已是最高级，无法使用；
	3. 更改SPI1由HAL库驱动方式改为LL库，提高通信性能；
	
	2022-11-14:
	1. 增加页面查询功能；

/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V06: 721100x_S02+版本电路（涉及7211001_S02+、7211002_S02+电路板PCBA）
2022-11-19:
	1. 针对新电路板（S02+），增加EEPROM_SCL,EEPROM_SDA引脚，Beep引脚替换为Charge_control;
	2. 电池检测逻辑重写；
	
2022-11-24：
	1. 屏幕重启时界面恢复
	
/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V07:
2022-12-05：
	1. 新增脚踏校正界面，以及设置界面中新增脚踏校正按钮；
	2. 更改CHARGE_CONTROL引脚为开漏输出，默认输出高电平
	
/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V08:
2022-12-10：
	1. 更换开关机开关为轻触开关，长按2s开机，长按2s关机，待机2分钟自动关机；
	2. 修复Bug
	
/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V09:
	1. 重新改写page_mode.c中每个工作模式下的功能函数，各个模式之间不再复用相同函数，尽可能独立运行；
	
/*----------------------------------------------------------------------------------------------------------------------------------*/
E_Flow_F411_V10:
2023-01-07:
	1. 硬件上将“开关机”键更改为触摸按键，新增触摸板PCBA: 7211005_S01；
	2. 触摸板按键开机信号电平与之前实体按键电平相反，牵扯到文件：user_data.c   power_control.h 
  
  
  ----readMe2.txt
  # 本文件主要记录E_Flow主控芯片外设核心配置：
0. timer1: 用于系统时基，优先级默认最高：0；
1. timer2: 用于电机控制，中断优先级最高：0；
2. wwdg:  软件开门狗，中断优先级仅次于timer2：1；
3. usart2: 串口外设2， 采用DMA传输，串口中断优先级：5；DMA中断优先级：5(TX 5, RX 5);

# 工程重新构建牵扯到的文件修改：
1. main.c   // 增加程序
2. freertos.c  // 增加程序
3. tim.c   // 优先级修改，定时间隔修改
4. wwdg.c   // 优先级修改
5. stm32f4xx_it.c // 增加程序


